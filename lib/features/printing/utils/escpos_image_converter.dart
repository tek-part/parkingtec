import 'package:flutter/foundation.dart';
import 'package:flutter_esc_pos_utils/flutter_esc_pos_utils.dart';
import 'package:image/image.dart' as img;
import 'package:parkingtec/features/printing/core/utils/paper_preset.dart';

/// ESC Command Builder
/// Converts image chunks to ESC/POS commands
class EscCommand {
  final List<Uint8List> _imageChunks = [];
  int _feedLines = 2;
  PaperPreset _paperPreset = PaperPreset.mm58;

  EscCommand();

  /// Set paper preset
  void setPaperPreset(PaperPreset paperPreset) {
    _paperPreset = paperPreset;
  }

  /// Clean command buffer
  Future<void> cleanCommand() async {
    _imageChunks.clear();
  }

  /// Add image chunk to command
  Future<void> addImageChunk(Uint8List imageBytes) async {
    _imageChunks.add(imageBytes);
  }

  /// Set feed lines
  Future<void> print({int feedLines = 2}) async {
    _feedLines = feedLines;
  }

  /// Get final command bytes from image chunks
  /// Converts PNG images to ESC/POS format
  Future<Uint8List?> getCommand() async {
    try {
      if (_imageChunks.isEmpty) {
        debugPrint('‚ùå No image chunks to print');
        return null;
      }

      debugPrint('‚úÖ Processing ${_imageChunks.length} image chunks');
      debugPrint(
        'üìÑ Paper size: ${_paperPreset.name} (${_paperPreset.widthMm}mm)',
      );

      List<int> bytes = [];

      // Load printer capability profile
      final profile = await CapabilityProfile.load();

      // Convert PaperPreset to PaperSize
      final paperSize = _paperPreset == PaperPreset.mm80
          ? PaperSize.mm80
          : PaperSize.mm58;

      final generator = Generator(paperSize, profile);

      // Reset printer
      bytes += generator.reset();

      // Convert and print each image chunk
      // First, combine all chunks into a single image to avoid spacing
      List<img.Image> decodedImages = [];
      int totalHeight = 0;
      int maxWidth = 0;

      for (int i = 0; i < _imageChunks.length; i++) {
        try {
          final pngBytes = _imageChunks[i];
          final decodedImage = img.decodeImage(pngBytes);
          if (decodedImage != null) {
            decodedImages.add(decodedImage);
            totalHeight += decodedImage.height;
            if (decodedImage.width > maxWidth) {
              maxWidth = decodedImage.width;
            }
          }
        } catch (e) {
          debugPrint('‚ùå Error decoding chunk ${i + 1}: $e');
        }
      }

      if (decodedImages.isEmpty) {
        debugPrint('‚ùå No valid images to print');
        return null;
      }

      // Create combined image
      final combinedImage = img.Image(width: maxWidth, height: totalHeight);
      int currentY = 0;
      for (final image in decodedImages) {
        img.compositeImage(combinedImage, image, dstX: 0, dstY: currentY);
        currentY += image.height;
      }

      // Convert combined image to ESC/POS format (single image, no spacing)
      final imageBytes = generator.image(combinedImage);
      bytes += imageBytes;

      // // Add feed lines only after all chunks (not between them)
      // bytes += generator.feed(_feedLines);

      // Cut paper
      bytes += generator.cut();

      debugPrint('‚úÖ Total bytes generated: ${bytes.length}');

      if (bytes.isEmpty) {
        debugPrint('‚ùå Generated bytes are empty');
        return null;
      }

      return Uint8List.fromList(bytes);
    } catch (e, s) {
      debugPrint('‚ùå Error building ticket bytes: $e');
      debugPrint('Stack trace: $s');
      return null;
    }
  }
}
